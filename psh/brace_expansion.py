"""Brace expansion implementation for psh.

Implements bash-style brace expansion as a pre-tokenization step.
Supports:
- List expansion: {a,b,c} → a b c
- Numeric sequences: {1..10} → 1 2 3 4 5 6 7 8 9 10
- Character sequences: {a..z} → a b c ... z
- Sequences with increment: {1..10..2} → 1 3 5 7 9
- Zero-padded sequences: {01..10} → 01 02 03 04 05 06 07 08 09 10
- Nested expansions: {{1..3},{a..c}} → 1 2 3 a b c
- Preamble/postscript: file{1..3}.txt → file1.txt file2.txt file3.txt
"""

from typing import List, Tuple, Optional


class BraceExpansionError(Exception):
    """Raised when brace expansion encounters an error."""
    pass


class BraceExpander:
    """Expands brace expressions in command lines before tokenization."""
    
    # Maximum number of items that can be generated by expansion
    MAX_EXPANSION_ITEMS = 10000
    
    def expand_line(self, line: str) -> str:
        """Expand all brace expressions in a command line.
        
        Args:
            line: The command line to expand
            
        Returns:
            The expanded command line with all brace expressions expanded
        """
        # Handle quoted sections specially - don't expand inside quotes
        segments = self._split_respecting_quotes(line)
        result_parts = []
        
        for segment, in_quotes in segments:
            if in_quotes:
                # Don't expand inside quotes
                result_parts.append(segment)
            else:
                # Expand braces in unquoted segment
                # We need to handle multiple brace expressions in the segment
                # while preserving the spaces and structure
                result_parts.append(self._expand_segment(segment))
        
        return ''.join(result_parts)
    
    def _expand_segment(self, segment: str) -> str:
        """Expand all brace expressions in an unquoted segment.
        
        This method handles the complexity of expanding braces while
        preserving the structure of the command line.
        """
        # We need to split the segment into tokens, but we must be careful
        # to keep brace expressions with their attached content (like {a,b}>out.txt)
        # together for proper expansion.
        
        tokens = []
        current_token = []
        i = 0
        
        while i < len(segment):
            if i < len(segment) - 1 and segment[i] == '\\':
                # Escaped character - include both backslash and next char
                current_token.append(segment[i])
                current_token.append(segment[i + 1])
                i += 2
                continue
            
            char = segment[i]
            
            # Check if we're at a word boundary (space, tab, newline, or command separator)
            if char in ' \t\n;|&':
                if current_token:
                    tokens.append(''.join(current_token))
                    current_token = []
                tokens.append(char)
            else:
                current_token.append(char)
            
            i += 1
        
        # Don't forget the last token
        if current_token:
            tokens.append(''.join(current_token))
        
        # Now process each token
        result = []
        for token in tokens:
            if token in ' \t\n':
                result.append(token)
            else:
                # Expand braces in this token
                expanded = self._expand_braces(token)
                if len(expanded) == 1:
                    result.append(expanded[0])
                else:
                    # Multiple expansions - join with spaces
                    result.append(' '.join(expanded))
        
        return ''.join(result)
    
    def _expand_braces(self, text: str) -> List[str]:
        """Expand all brace expressions in text, returning list of results.
        
        This handles nested braces by repeatedly expanding until no more
        brace expressions are found.
        """
        # First check if braces are balanced
        if not self._are_braces_balanced(text):
            # Don't expand if braces are unbalanced
            return [text]
        
        results = [text]
        
        # Keep expanding until no more brace expressions found
        while True:
            new_results = []
            expanded_any = False
            
            for item in results:
                expanded = self._expand_one_brace(item)
                if len(expanded) > 1 or (expanded and expanded[0] != item):
                    expanded_any = True
                new_results.extend(expanded)
            
            results = new_results
            
            # Check expansion limit
            if len(results) > self.MAX_EXPANSION_ITEMS:
                raise BraceExpansionError(
                    f"Brace expansion would create {len(results)} items "
                    f"(limit: {self.MAX_EXPANSION_ITEMS})"
                )
            
            if not expanded_any:
                break
        
        return results
    
    def _are_braces_balanced(self, text: str) -> bool:
        """Check if braces are properly balanced in text."""
        depth = 0
        escaped = False
        
        for char in text:
            if escaped:
                escaped = False
                continue
            
            if char == '\\':
                escaped = True
                continue
                
            if char == '{':
                depth += 1
            elif char == '}':
                depth -= 1
                if depth < 0:
                    # More closing than opening
                    return False
        
        # Check if all braces were closed
        return depth == 0
    
    def _expand_one_brace(self, text: str) -> List[str]:
        """Expand the first brace expression found in text.
        
        Returns a list with the expanded results, or [text] if no
        valid brace expression is found.
        """
        # Find a complete brace expression
        brace_match = self._find_brace_expression(text)
        if not brace_match:
            return [text]
        
        start, end, brace_content = brace_match
        prefix = text[:start]
        suffix = text[end:]
        
        # Special handling for shell metacharacters in suffix
        # If the suffix starts with certain metacharacters that should not be
        # attached to each expansion, we need to handle them differently
        attach_suffix = suffix
        detached_suffix = ""
        
        # Check if suffix starts with a shell metacharacter that should be detached
        # from the brace expansion (applies to both sequences and lists)
        if suffix:
            # Check for multi-character operators first
            multi_char_operators = ['&&', '||', '>>', '<<']
            detach_operator = None
            
            for op in multi_char_operators:
                if suffix.startswith(op):
                    detach_operator = op
                    break
            
            # Check for single-character operators
            if not detach_operator and suffix[0] in ';|&)]}':
                detach_operator = suffix[0]
            
            if detach_operator:
                # For brace expansions followed by shell operators, detach them
                attach_suffix = ""
                detached_suffix = suffix
        
        # Determine brace type and expand
        # Check if it's a list (has comma at top level) or pure sequence
        if self._has_top_level_comma(brace_content):
            # List expansion (may contain nested sequences)
            expanded = self._expand_list(brace_content)
        elif '..' in brace_content:
            # Pure sequence expansion
            expanded = self._expand_sequence(brace_content)
            if expanded is None:
                # Invalid sequence, return unexpanded
                return [text]
        else:
            # No comma and no .., not a valid brace expression
            return [text]
        
        # Combine with prefix/suffix
        if detached_suffix:
            # Join expanded items with spaces, then add the detached suffix
            return [prefix + ' '.join(expanded) + detached_suffix]
        else:
            # Normal case - attach suffix to each item
            return [prefix + item + attach_suffix for item in expanded]
    
    def _expand_list(self, content: str) -> List[str]:
        """Expand comma-separated list like a,b,c.
        
        Handles nested braces by careful parsing of the content.
        """
        # Parse the content respecting nested braces
        items = []
        current = []
        depth = 0
        escaped = False
        
        for i, char in enumerate(content):
            if escaped:
                current.append(char)
                escaped = False
                continue
                
            if char == '\\':
                escaped = True
                current.append(char)
            elif char == '{':
                depth += 1
                current.append(char)
            elif char == '}':
                depth -= 1
                current.append(char)
            elif char == ',' and depth == 0:
                # Found a separator at top level
                items.append(''.join(current))
                current = []
            else:
                current.append(char)
        
        # Don't forget the last item
        items.append(''.join(current))
        
        # Recursively expand any nested braces in items
        expanded_items = []
        for item in items:
            # Empty items should remain empty
            if item == '':
                expanded_items.append('')
            else:
                # Check if this item contains a sequence
                if '..' in item and '{' in item and '}' in item:
                    # This might be a nested sequence like {1..3}
                    expanded = self._expand_braces(item)
                    expanded_items.extend(expanded)
                else:
                    # Regular item or already expanded
                    expanded_items.extend(self._expand_braces(item))
        
        return expanded_items
    
    def _find_brace_expression(self, text: str) -> Optional[Tuple[int, int, str]]:
        """Find the first valid brace expression in text.
        
        Returns:
            Tuple of (start_index, end_index, content) or None if not found.
            end_index is one past the closing brace.
        """
        depth = 0
        start = -1
        escaped = False
        
        for i, char in enumerate(text):
            if escaped:
                escaped = False
                continue
                
            if char == '\\':
                escaped = True
                continue
                
            if char == '{':
                if depth == 0:
                    # Check if this is a variable expansion ${...}
                    if i > 0 and text[i-1] == '$':
                        # This is a variable expansion, not a brace expansion
                        # Skip to the closing brace
                        j = i + 1
                        brace_depth = 1
                        while j < len(text) and brace_depth > 0:
                            if text[j] == '{':
                                brace_depth += 1
                            elif text[j] == '}':
                                brace_depth -= 1
                            j += 1
                        i = j - 1  # Will be incremented by the loop
                        continue
                    start = i
                depth += 1
            elif char == '}':
                depth -= 1
                if depth == 0 and start >= 0:
                    content = text[start+1:i]
                    # Validate it's a real brace expression
                    if self._is_valid_brace_content(content):
                        return (start, i+1, content)
                    # Not valid, reset and continue looking
                    start = -1
                elif depth < 0:
                    # More closing than opening braces - this is invalid
                    # Don't try to expand anything
                    return None
        
        # If we have unclosed braces, don't expand
        if depth > 0:
            return None
        
        return None
    
    def _is_valid_brace_content(self, content: str) -> bool:
        """Check if content represents a valid brace expression.
        
        Valid expressions have either:
        - A comma at the top level (not inside nested braces)
        - A '..' sequence (for range expansion)
        """
        if not content:
            return False
        
        # Check for sequence (Phase 2 - recognize but don't expand yet)
        if '..' in content:
            return True
        
        # Check for list (must have comma not inside nested braces)
        depth = 0
        escaped = False
        has_comma = False
        
        for char in content:
            if escaped:
                escaped = False
                continue
                
            if char == '\\':
                escaped = True
            elif char == '{':
                depth += 1
            elif char == '}':
                depth -= 1
            elif char == ',' and depth == 0:
                has_comma = True
        
        # Also check that we don't have spaces around commas
        # "{a, b, c}" should not expand
        if has_comma and not self._has_spaces_around_commas(content):
            return True
            
        return False
    
    def _has_spaces_around_commas(self, content: str) -> bool:
        """Check if content has spaces around any top-level commas."""
        depth = 0
        escaped = False
        
        for i, char in enumerate(content):
            if escaped:
                escaped = False
                continue
                
            if char == '\\':
                escaped = True
            elif char == '{':
                depth += 1
            elif char == '}':
                depth -= 1
            elif char == ',' and depth == 0:
                # Check for spaces around this comma
                if (i > 0 and content[i-1] == ' ') or \
                   (i < len(content)-1 and content[i+1] == ' '):
                    return True
        
        return False
    
    def _has_top_level_comma(self, content: str) -> bool:
        """Check if content has a comma at top level (not inside nested braces)."""
        depth = 0
        escaped = False
        
        for char in content:
            if escaped:
                escaped = False
                continue
                
            if char == '\\':
                escaped = True
            elif char == '{':
                depth += 1
            elif char == '}':
                depth -= 1
            elif char == ',' and depth == 0:
                return True
        
        return False
    
    def _split_respecting_quotes(self, line: str) -> List[Tuple[str, bool]]:
        """Split line into segments, tracking which are inside quotes.
        
        Returns:
            List of (segment, in_quotes) tuples
        """
        segments = []
        current = []
        in_single_quotes = False
        in_double_quotes = False
        escaped = False
        
        i = 0
        while i < len(line):
            char = line[i]
            
            if escaped:
                current.append(char)
                escaped = False
                i += 1
                continue
            
            if char == '\\' and i + 1 < len(line):
                # Handle escape
                current.append(char)
                escaped = True
                i += 1
                continue
            
            if char == "'" and not in_double_quotes:
                if in_single_quotes:
                    # End single quotes
                    current.append(char)
                    segments.append((''.join(current), True))
                    current = []
                    in_single_quotes = False
                else:
                    # Start single quotes
                    if current:
                        segments.append((''.join(current), False))
                        current = []
                    current.append(char)
                    in_single_quotes = True
            elif char == '"' and not in_single_quotes:
                if in_double_quotes:
                    # End double quotes
                    current.append(char)
                    segments.append((''.join(current), True))
                    current = []
                    in_double_quotes = False
                else:
                    # Start double quotes
                    if current:
                        segments.append((''.join(current), False))
                        current = []
                    current.append(char)
                    in_double_quotes = True
            else:
                current.append(char)
            
            i += 1
        
        # Handle any remaining content
        if current:
            segments.append((''.join(current), 
                           in_single_quotes or in_double_quotes))
        
        return segments
    
    def _expand_sequence(self, content: str) -> Optional[List[str]]:
        """Expand sequence like 1..10 or a..z.
        
        Returns None if the sequence is invalid.
        """
        # Parse the sequence
        parts = content.split('..')
        if len(parts) < 2 or len(parts) > 3:
            return None
        
        start = parts[0]
        end = parts[1]
        increment = parts[2] if len(parts) == 3 else '1'
        
        # Try numeric sequence first
        numeric_result = self._try_numeric_sequence(start, end, increment)
        if numeric_result is not None:
            return numeric_result
        
        # Try character sequence
        char_result = self._try_char_sequence(start, end, increment)
        if char_result is not None:
            return char_result
        
        # Invalid sequence
        return None
    
    def _try_numeric_sequence(self, start: str, end: str, increment: str) -> Optional[List[str]]:
        """Try to expand as numeric sequence.
        
        Returns None if not valid numeric sequence.
        """
        try:
            # Parse numbers
            start_num = int(start)
            end_num = int(end)
            inc_num = int(increment)
            
            # Handle increment of 0
            if inc_num == 0:
                inc_num = 1
            
            # Determine direction
            if start_num <= end_num:
                inc_num = abs(inc_num)
            else:
                inc_num = -abs(inc_num)
            
            # Determine padding
            padding = self._determine_numeric_padding(start, end)
            
            # Generate sequence
            result = []
            current = start_num
            while (inc_num > 0 and current <= end_num) or (inc_num < 0 and current >= end_num):
                if padding < 0:
                    # Special case: -3..03 style
                    # Negative numbers don't get padded, positive do
                    if current < 0:
                        result.append(str(current))
                    else:
                        result.append(str(current).zfill(-padding))
                elif padding > 0:
                    # Handle padding based on whether range crosses zero
                    if start_num < 0 and end_num >= 0:
                        # Range crosses zero - bash uses special padding
                        # Negative numbers get one less padding digit than positive
                        if current < 0:
                            result.append('-' + str(abs(current)).zfill(padding))
                        else:
                            # Zero and positive get extra digit
                            result.append(str(current).zfill(padding + 1))
                    else:
                        # Normal padding
                        if current < 0:
                            result.append('-' + str(abs(current)).zfill(padding))
                        else:
                            result.append(str(current).zfill(padding))
                else:
                    result.append(str(current))
                current += inc_num
            
            return result
            
        except ValueError:
            return None
    
    def _try_char_sequence(self, start: str, end: str, increment: str) -> Optional[List[str]]:
        """Try to expand as character sequence.
        
        Returns None if not valid character sequence.
        """
        # Must be single characters
        if len(start) != 1 or len(end) != 1:
            return None
        
        # Must be ASCII letters
        start_ord = ord(start)
        end_ord = ord(end)
        
        # For character sequences, we accept any ASCII character between bounds
        # but start and end must be letters for the sequence to be valid
        if not ((start.isalpha() and end.isalpha()) or 
                (start.isdigit() and end.isdigit())):
            # Special case: allow cross-case sequences like A..z
            if not (start.isalpha() and end.isalpha()):
                return None
        
        try:
            inc_num = int(increment)
            if inc_num == 0:
                inc_num = 1
        except ValueError:
            return None
        
        # Determine direction
        if start_ord <= end_ord:
            inc_num = abs(inc_num)
        else:
            inc_num = -abs(inc_num)
        
        # Generate sequence
        result = []
        current = start_ord
        while (inc_num > 0 and current <= end_ord) or (inc_num < 0 and current >= end_ord):
            result.append(chr(current))
            current += inc_num
        
        return result
    
    def _determine_numeric_padding(self, start: str, end: str) -> int:
        """Determine zero-padding width for numeric sequence.
        
        Returns 0 if no padding needed.
        """
        # Remove sign for padding calculation
        start_digits = start.lstrip('-+')
        end_digits = end.lstrip('-+')
        
        # Check if either has leading zeros
        has_start_padding = len(start_digits) > 1 and start_digits.startswith('0')
        has_end_padding = len(end_digits) > 1 and end_digits.startswith('0')
        
        if not (has_start_padding or has_end_padding):
            return 0
        
        # For single digit negative padded number like -3 with end 03,
        # we don't pad the negative numbers
        start_val = int(start)
        end_val = int(end)
        
        # If start is negative without padding and end has padding
        if start_val < 0 and not has_start_padding and has_end_padding:
            # Return 0 to indicate special handling
            return -len(end_digits)  # Negative indicates special case
        
        # Padding is the max length
        return max(len(start_digits), len(end_digits))