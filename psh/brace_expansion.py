"""Brace expansion implementation for psh.

Implements bash-style brace expansion as a pre-tokenization step.
Handles {a,b,c} list expansion and {1..10} sequence expansion.
"""

from typing import List, Tuple, Optional


class BraceExpansionError(Exception):
    """Raised when brace expansion encounters an error."""
    pass


class BraceExpander:
    """Expands brace expressions in command lines before tokenization."""
    
    # Maximum number of items that can be generated by expansion
    MAX_EXPANSION_ITEMS = 10000
    
    def expand_line(self, line: str) -> str:
        """Expand all brace expressions in a command line.
        
        Args:
            line: The command line to expand
            
        Returns:
            The expanded command line with all brace expressions expanded
        """
        # Handle quoted sections specially - don't expand inside quotes
        segments = self._split_respecting_quotes(line)
        result_parts = []
        
        for segment, in_quotes in segments:
            if in_quotes:
                # Don't expand inside quotes
                result_parts.append(segment)
            else:
                # Expand braces in unquoted segment
                # We need to handle multiple brace expressions in the segment
                # while preserving the spaces and structure
                result_parts.append(self._expand_segment(segment))
        
        return ''.join(result_parts)
    
    def _expand_segment(self, segment: str) -> str:
        """Expand all brace expressions in an unquoted segment.
        
        This method handles the complexity of expanding braces while
        preserving the structure of the command line.
        """
        # We need to handle whitespace properly while still allowing
        # brace expressions that span across special characters
        # Split on whitespace only
        parts = []
        current = []
        
        for char in segment:
            if char in ' \t\n':
                if current:
                    # Expand the accumulated part
                    text = ''.join(current)
                    expanded = self._expand_braces(text)
                    parts.append(' '.join(expanded))
                    current = []
                parts.append(char)
            else:
                current.append(char)
        
        # Don't forget the last part
        if current:
            text = ''.join(current)
            expanded = self._expand_braces(text)
            parts.append(' '.join(expanded))
        
        return ''.join(parts)
    
    def _expand_braces(self, text: str) -> List[str]:
        """Expand all brace expressions in text, returning list of results.
        
        This handles nested braces by repeatedly expanding until no more
        brace expressions are found.
        """
        # First check if braces are balanced
        if not self._are_braces_balanced(text):
            # Don't expand if braces are unbalanced
            return [text]
        
        results = [text]
        
        # Keep expanding until no more brace expressions found
        while True:
            new_results = []
            expanded_any = False
            
            for item in results:
                expanded = self._expand_one_brace(item)
                if len(expanded) > 1 or (expanded and expanded[0] != item):
                    expanded_any = True
                new_results.extend(expanded)
            
            results = new_results
            
            # Check expansion limit
            if len(results) > self.MAX_EXPANSION_ITEMS:
                raise BraceExpansionError(
                    f"Brace expansion would create {len(results)} items "
                    f"(limit: {self.MAX_EXPANSION_ITEMS})"
                )
            
            if not expanded_any:
                break
        
        return results
    
    def _are_braces_balanced(self, text: str) -> bool:
        """Check if braces are properly balanced in text."""
        depth = 0
        escaped = False
        
        for char in text:
            if escaped:
                escaped = False
                continue
            
            if char == '\\':
                escaped = True
                continue
                
            if char == '{':
                depth += 1
            elif char == '}':
                depth -= 1
                if depth < 0:
                    # More closing than opening
                    return False
        
        # Check if all braces were closed
        return depth == 0
    
    def _expand_one_brace(self, text: str) -> List[str]:
        """Expand the first brace expression found in text.
        
        Returns a list with the expanded results, or [text] if no
        valid brace expression is found.
        """
        # Find a complete brace expression
        brace_match = self._find_brace_expression(text)
        if not brace_match:
            return [text]
        
        start, end, brace_content = brace_match
        prefix = text[:start]
        suffix = text[end:]
        
        # Determine brace type and expand
        if '..' in brace_content:
            # Sequence expansion (Phase 2 - return unexpanded for now)
            return [text]
        else:
            # List expansion
            expanded = self._expand_list(brace_content)
        
        # Combine with prefix/suffix
        return [prefix + item + suffix for item in expanded]
    
    def _expand_list(self, content: str) -> List[str]:
        """Expand comma-separated list like a,b,c.
        
        Handles nested braces by careful parsing of the content.
        """
        # Parse the content respecting nested braces
        items = []
        current = []
        depth = 0
        escaped = False
        
        for i, char in enumerate(content):
            if escaped:
                current.append(char)
                escaped = False
                continue
                
            if char == '\\':
                escaped = True
                current.append(char)
            elif char == '{':
                depth += 1
                current.append(char)
            elif char == '}':
                depth -= 1
                current.append(char)
            elif char == ',' and depth == 0:
                # Found a separator at top level
                items.append(''.join(current))
                current = []
            else:
                current.append(char)
        
        # Don't forget the last item
        items.append(''.join(current))
        
        # Recursively expand any nested braces in items
        expanded_items = []
        for item in items:
            # Empty items should remain empty
            if item == '':
                expanded_items.append('')
            else:
                expanded_items.extend(self._expand_braces(item))
        
        return expanded_items
    
    def _find_brace_expression(self, text: str) -> Optional[Tuple[int, int, str]]:
        """Find the first valid brace expression in text.
        
        Returns:
            Tuple of (start_index, end_index, content) or None if not found.
            end_index is one past the closing brace.
        """
        depth = 0
        start = -1
        escaped = False
        
        for i, char in enumerate(text):
            if escaped:
                escaped = False
                continue
                
            if char == '\\':
                escaped = True
                continue
                
            if char == '{':
                if depth == 0:
                    start = i
                depth += 1
            elif char == '}':
                depth -= 1
                if depth == 0 and start >= 0:
                    content = text[start+1:i]
                    # Validate it's a real brace expression
                    if self._is_valid_brace_content(content):
                        return (start, i+1, content)
                    # Not valid, reset and continue looking
                    start = -1
                elif depth < 0:
                    # More closing than opening braces - this is invalid
                    # Don't try to expand anything
                    return None
        
        # If we have unclosed braces, don't expand
        if depth > 0:
            return None
        
        return None
    
    def _is_valid_brace_content(self, content: str) -> bool:
        """Check if content represents a valid brace expression.
        
        Valid expressions have either:
        - A comma at the top level (not inside nested braces)
        - A '..' sequence (for range expansion)
        """
        if not content:
            return False
        
        # Check for sequence (Phase 2 - recognize but don't expand yet)
        if '..' in content:
            return True
        
        # Check for list (must have comma not inside nested braces)
        depth = 0
        escaped = False
        has_comma = False
        
        for char in content:
            if escaped:
                escaped = False
                continue
                
            if char == '\\':
                escaped = True
            elif char == '{':
                depth += 1
            elif char == '}':
                depth -= 1
            elif char == ',' and depth == 0:
                has_comma = True
        
        # Also check that we don't have spaces around commas
        # "{a, b, c}" should not expand
        if has_comma and not self._has_spaces_around_commas(content):
            return True
            
        return False
    
    def _has_spaces_around_commas(self, content: str) -> bool:
        """Check if content has spaces around any top-level commas."""
        depth = 0
        escaped = False
        
        for i, char in enumerate(content):
            if escaped:
                escaped = False
                continue
                
            if char == '\\':
                escaped = True
            elif char == '{':
                depth += 1
            elif char == '}':
                depth -= 1
            elif char == ',' and depth == 0:
                # Check for spaces around this comma
                if (i > 0 and content[i-1] == ' ') or \
                   (i < len(content)-1 and content[i+1] == ' '):
                    return True
        
        return False
    
    def _split_respecting_quotes(self, line: str) -> List[Tuple[str, bool]]:
        """Split line into segments, tracking which are inside quotes.
        
        Returns:
            List of (segment, in_quotes) tuples
        """
        segments = []
        current = []
        in_single_quotes = False
        in_double_quotes = False
        escaped = False
        
        i = 0
        while i < len(line):
            char = line[i]
            
            if escaped:
                current.append(char)
                escaped = False
                i += 1
                continue
            
            if char == '\\' and i + 1 < len(line):
                # Handle escape
                current.append(char)
                escaped = True
                i += 1
                continue
            
            if char == "'" and not in_double_quotes:
                if in_single_quotes:
                    # End single quotes
                    current.append(char)
                    segments.append((''.join(current), True))
                    current = []
                    in_single_quotes = False
                else:
                    # Start single quotes
                    if current:
                        segments.append((''.join(current), False))
                        current = []
                    current.append(char)
                    in_single_quotes = True
            elif char == '"' and not in_single_quotes:
                if in_double_quotes:
                    # End double quotes
                    current.append(char)
                    segments.append((''.join(current), True))
                    current = []
                    in_double_quotes = False
                else:
                    # Start double quotes
                    if current:
                        segments.append((''.join(current), False))
                        current = []
                    current.append(char)
                    in_double_quotes = True
            else:
                current.append(char)
            
            i += 1
        
        # Handle any remaining content
        if current:
            segments.append((''.join(current), 
                           in_single_quotes or in_double_quotes))
        
        return segments